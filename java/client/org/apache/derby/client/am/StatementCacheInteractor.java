package org.apache.derby.client.am;

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.apache.derby.client.am.stmtcache.JDBCStatementCache;
import org.apache.derby.client.am.stmtcache.StatementKey;
import org.apache.derby.client.am.stmtcache.StatementKeyFactory;
import org.apache.derby.jdbc.ClientDriver;

/**
 * Utility class encapsulating the logic for interacting with the JDBC statement
 * cache when creating new logical statements.
 * <p>
 * This class was introduced to share code between the pre-JDBC 4 and the JDBC
 * 4+ versions of the JDBC classes.
 * <p>
 * The pattern for the {@code prepareX} methods is:
 * <ol> <li>Generate a key for the statement to create.</li>
 *      <li>Consult cache to see if an existing statement can be used.</li>
 *      <li>Create new statement on physical connection if necessary.</li>
 *      <li>Return referecne to existing or newly created statement.</li>
 * </ol>
 */
final class StatementCacheInteractor {

    /** TODO: Fetch from connection, see DERBY-3192. */
    private final String currentSchema = "APP";
    /** Statement cache for the associated physical connection. */
    private final JDBCStatementCache cache;
    /**
     * The underlying physical connection.
     * <p>
     * Note that it is the responsibility of the logical statement assoiciated
     * with this cache interactor to ensure the interactor methods are not
     * invoked if the logical statement has been closed.
     */
    private final Connection physicalConnection;

    /**
     * Creates a new JDBC statement cache interactor.
     *
     * @param cache statement cache
     * @param physicalConnection associated physical connection
     */
    StatementCacheInteractor(JDBCStatementCache cache,
                             Connection physicalConnection) {
        this.cache = cache;
        this.physicalConnection = physicalConnection;
    }

    /**
     * @see java.sql.Connection#prepareStatement(String)
     */
    public synchronized PreparedStatement prepareStatement(String sql)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newPrepared(
                sql, currentSchema, physicalConnection.holdability());
        PreparedStatement ps = cache.getCached(stmtKey);
        if (ps == null) {
            ps = physicalConnection.prepareStatement(sql);
        }
        return ClientDriver.getFactory().newLogicalPreparedStatement(
                    ps, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareStatement(String,int,int)
     */
    public synchronized PreparedStatement prepareStatement(
                                                String sql,
                                                int resultSetType,
                                                int resultSetConcurrency)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newPrepared(
                sql, currentSchema, resultSetType, resultSetConcurrency,
                physicalConnection.holdability());
        PreparedStatement ps = cache.getCached(stmtKey);
        if (ps == null) {
            ps = physicalConnection.prepareStatement(
                    sql, resultSetType, resultSetConcurrency);
        }
        return ClientDriver.getFactory().newLogicalPreparedStatement(
                ps, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareStatement(String,int,int,int)
     */
    public synchronized PreparedStatement prepareStatement(
                                                String sql,
                                                int resultSetType,
                                                int resultSetConcurrency,
                                                int resultSetHoldability)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newPrepared(
                sql, currentSchema, resultSetType, resultSetConcurrency,
                resultSetHoldability);

        PreparedStatement ps = cache.getCached(stmtKey);
        if (ps == null) {
            ps = physicalConnection.prepareStatement(
                sql, resultSetType,resultSetConcurrency, resultSetHoldability);
        }
        return ClientDriver.getFactory().newLogicalPreparedStatement(
                    ps, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareStatement(String,int)
     */
    public synchronized PreparedStatement prepareStatement(
                                                String sql,
                                                int autoGeneratedKeys)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newPrepared(
                sql, currentSchema, physicalConnection.getHoldability(),
                autoGeneratedKeys);
        PreparedStatement ps = cache.getCached(stmtKey);
        if (ps == null) {
            ps = physicalConnection.prepareStatement(sql, autoGeneratedKeys);
        }
        return ClientDriver.getFactory().newLogicalPreparedStatement(
                    ps, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareCall(String)
     */
    public synchronized CallableStatement prepareCall(String sql)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newCallable(
                sql, currentSchema, physicalConnection.holdability());
        CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
        if (cs == null) {
            cs = physicalConnection.prepareCall(sql);
        }
        return ClientDriver.getFactory().newLogicalCallableStatement(
                    cs, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareCall(String,int,int)
     */
    public synchronized CallableStatement prepareCall(String sql,
                                                      int resultSetType,
                                                      int resultSetConcurrency)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newCallable(
                sql, currentSchema, resultSetType, resultSetConcurrency,
                physicalConnection.holdability());
        CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
        if (cs == null) {
            cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
        }
        return ClientDriver.getFactory().newLogicalCallableStatement(
                    cs, stmtKey, cache);
    }

    /**
     * @see java.sql.Connection#prepareCall(String,int,int,int)
     */
    public synchronized CallableStatement prepareCall(String sql,
                                                      int resultSetType,
                                                      int resultSetConcurrency,
                                                      int resultSetHoldability)
            throws SQLException {
        StatementKey stmtKey = StatementKeyFactory.newCallable(
                sql, currentSchema, resultSetType, resultSetConcurrency,
                resultSetHoldability);
        CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
        if (cs == null) {
            cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency,
                    resultSetHoldability);
        }
        return ClientDriver.getFactory().newLogicalCallableStatement(
                    cs, stmtKey, cache);
    }
}
